FunctionPrograming
自修改代码: 以前,为了适应程序有限内存,修改内存中的代码,从而执行不同操作
为了更加通俗易懂 产生高级语言
使用代码以某种方式操作其他代码 --> 函数式编程 --> 通过合并现有代码完成满足新功能

OO 抽象数据   FP 抽象行为

特点: 不改变旧值,产生新值


1.新旧对比

如果希望方法在调用时行为不同,怎么做？将代码传给方法 即可控制行为

如 Strategize  所示

结论: 构造器和内部类传递功能,都较为笨拙,方法和lambda 比较方便

2.lambda 表达式

如 Strategize所示

任何 Lambda 表达式的基本语法是：
1. 参数。
2. 接着 ->，可视为“产出”。
3. -> 之后的内容都是方法体。
   • [1] 当只用一个参数，可以不需要括号 ()。然而，这是一个特例。
   • [2] 正常情况使用括号 () 包裹参数。为了保持一致性，也可以使用括号 () 包裹单个参数，虽然
   这种情况并不常见。
   • [3] 如果没有参数，则必须使用括号 () 表示空参数列表。
   • [4] 对于多个参数，将参数列表放在括号 () 中。
   • [5]   需要多行 ,花括号, 并且return
   
3.递归
   如RecursiveFibonacci  和  RecursiveFactorial 所示

4.方法调用
     1.runable 接口
            如RunnableMethodReference 所示
    2.未绑定的方法引用 
           非static方法 接口中第一个参数传入对象实例
    3.构造函数引用
            编译器根据接口参数数量,类型识别调用哪个函数构造器
    4.函数式接口
            这里提供了一部分内置的interface 方便日常使用 @FunctionalInterface 每个接口包含一个抽象式的方法
    5.多参数式函数式接口
            可以自己模仿函数式接口生成新的函数式接口
    6.缺少基本类型的函数
            使用频率决定
5.高阶函数
        只是一个消费或产生函数的函数
        如ProduceFunction所示 在方法中产生了一个函数
        如ProduceFunction所示 在方法中消费了一个函数

        可以混用 消费并产生函数  如TransformFunction所示
6.闭包
    方法引用了方法局部变量之外的变量 就是一个闭包
    定义; 闭包是由函数和其相关的引用环境(方法外变量)组合而产生的实体

    如果希望系统方法和当前环境的上下文绑定的话 就可以使用闭包
    
    使用闭包的设计方式,由于闭包本身已经包含了上下文信息,所以可以对北向功能调用,屏蔽由于环境而引发的复杂处理和交互成本
7.函数组合
    andThen compose     谓词: and or negate

8.柯里化和部分求值
        柯里化: 把一个多参数的函数,构造成一个一系列单参数函数
